"""
Vulnerability Tracking Agent for npm Audit Data
Uses Strands SDK with Claude Sonnet on Amazon Bedrock
"""

import json
import os
from pathlib import Path

import pandas as pd
from strands import Agent, tool

# Configuration
AWS_REGION = os.environ.get("AWS_REGION", "us-east-1")
DATA_DIR = os.path.join(os.path.dirname(__file__), "..", "data", "npm-audits")


def load_vulnerability_data():
    """Load npm audit data from all repo JSON files."""
    all_vulnerabilities = []

    if not os.path.exists(DATA_DIR):
        return all_vulnerabilities

    for filepath in Path(DATA_DIR).glob("*.json"):
        repo_name = filepath.stem  # filename without .json

        try:
            with open(filepath, "r") as f:
                audit_data = json.load(f)
        except (json.JSONDecodeError, IOError):
            print(f"[Warning] Could not parse {filepath}")
            continue

        vulnerabilities = audit_data.get("vulnerabilities", {})

        for package_name, vuln_info in vulnerabilities.items():
            # Handle via field (can be array of objects or array of strings)
            via = vuln_info.get("via", [])
            advisory_info = {"advisory_title": "", "advisory_url": "", "cwe": "", "cvss_score": 0.0}

            # via can be mixed list of dicts (direct advisories) and strings (transitive deps)
            if via:
                # Find first dict in via for advisory info
                dict_via = [v for v in via if isinstance(v, dict)]
                str_via = [v for v in via if isinstance(v, str)]

                if dict_via:
                    advisory_info = {
                        "advisory_title": dict_via[0].get("title", ""),
                        "advisory_url": dict_via[0].get("url", ""),
                        "cwe": dict_via[0].get("cwe", [""])[0] if dict_via[0].get("cwe") else "",
                        "cvss_score": (
                            dict_via[0].get("cvss", {}).get("score", 0.0)
                            if isinstance(dict_via[0].get("cvss"), dict)
                            else 0.0
                        ),
                    }
                elif str_via:
                    # via is list of package names (transitive deps)
                    advisory_info["advisory_title"] = f"Vulnerability via {', '.join(str_via)}"

            # Handle fixAvailable (can be bool or object)
            fix_available = vuln_info.get("fixAvailable", False)
            if isinstance(fix_available, dict):
                fix_info = {
                    "fix_available": True,
                    "fix_version": fix_available.get("version", ""),
                    "is_major_bump": fix_available.get("isSemVerMajor", False),
                }
            else:
                fix_info = {"fix_available": bool(fix_available), "fix_version": "", "is_major_bump": False}

            all_vulnerabilities.append(
                {
                    "repo": repo_name,
                    "package": vuln_info.get("name", package_name),
                    "severity": vuln_info.get("severity", "unknown"),
                    "is_direct": vuln_info.get("isDirect", False),
                    "vulnerable_range": vuln_info.get("range", ""),
                    "effects": vuln_info.get("effects", []),
                    "nodes": vuln_info.get("nodes", []),
                    **advisory_info,
                    **fix_info,
                }
            )

    return all_vulnerabilities


# Load data at module level
VULNERABILITIES = load_vulnerability_data()


@tool
def get_vulnerability_overview(severity_filter: str = "all") -> str:
    """Get overview of vulnerabilities across all repos.

    Args:
        severity_filter: Filter by severity - 'all', 'critical', 'high', 'moderate', 'low', 'info'

    Returns:
        str: JSON summary with counts by severity, repo, and fix availability
    """
    print(f"[Tool] get_vulnerability_overview: severity={severity_filter}")

    df = pd.DataFrame(VULNERABILITIES)

    if df.empty:
        return json.dumps({"error": "No vulnerability data available. Add npm audit JSON files to data/npm-audits/"})

    # Apply severity filter
    if severity_filter != "all":
        df = df[df["severity"] == severity_filter.lower()]

    summary = {
        "total_vulnerabilities": len(df),
        "total_repos": int(df["repo"].nunique()),
        "by_severity": df["severity"].value_counts().to_dict(),
        "by_repo": df.groupby("repo").size().to_dict(),
        "direct_dependencies": int(df["is_direct"].sum()),
        "transitive_dependencies": int((~df["is_direct"]).sum()),
        "fixable": int(df["fix_available"].sum()),
        "requires_major_bump": int(df[df["fix_available"]]["is_major_bump"].sum()) if df["fix_available"].any() else 0,
        "top_vulnerable_packages": df["package"].value_counts().head(10).to_dict(),
    }

    print(f"[Tool] Found {summary['total_vulnerabilities']} vulnerabilities across {summary['total_repos']} repos")
    return json.dumps(summary, indent=2)


@tool
def search_by_package(package_name: str) -> str:
    """Find all vulnerabilities for a specific package across all repos.

    Args:
        package_name: Name of the npm package to search for

    Returns:
        str: JSON list of vulnerabilities for that package
    """
    print(f"[Tool] search_by_package: {package_name}")

    df = pd.DataFrame(VULNERABILITIES)

    if df.empty:
        return json.dumps({"error": "No vulnerability data available"})

    # Case-insensitive search
    matches = df[df["package"].str.contains(package_name, case=False, na=False)]

    if matches.empty:
        return json.dumps(
            {
                "package": package_name,
                "found": False,
                "message": f"No vulnerabilities found for package '{package_name}'",
            }
        )

    result = {
        "package": package_name,
        "found": True,
        "total_instances": len(matches),
        "affected_repos": matches["repo"].unique().tolist(),
        "severities": matches["severity"].value_counts().to_dict(),
        "vulnerabilities": matches.to_dict("records"),
    }

    print(f"[Tool] Found {len(matches)} vulnerabilities in {len(result['affected_repos'])} repos")
    return json.dumps(result, indent=2, default=str)


@tool
def search_by_repo(repo_name: str) -> str:
    """Get all vulnerabilities for a specific repository.

    Args:
        repo_name: Name of the repository to check

    Returns:
        str: JSON list of vulnerabilities with summary stats
    """
    print(f"[Tool] search_by_repo: {repo_name}")

    df = pd.DataFrame(VULNERABILITIES)

    if df.empty:
        return json.dumps({"error": "No vulnerability data available"})

    # Partial match for repo name
    matches = df[df["repo"].str.contains(repo_name, case=False, na=False)]

    if matches.empty:
        available_repos = df["repo"].unique().tolist()
        return json.dumps(
            {
                "repo": repo_name,
                "found": False,
                "message": f"No repository found matching '{repo_name}'",
                "available_repos": available_repos[:10],
            }
        )

    # Get exact repo if multiple partial matches
    exact_matches = df[df["repo"] == repo_name]
    if not exact_matches.empty:
        matches = exact_matches

    repo_actual = matches["repo"].iloc[0]

    result = {
        "repo": repo_actual,
        "total_vulnerabilities": len(matches),
        "by_severity": matches["severity"].value_counts().to_dict(),
        "direct_dependencies": int(matches["is_direct"].sum()),
        "transitive_dependencies": int((~matches["is_direct"]).sum()),
        "fixable": int(matches["fix_available"].sum()),
        "critical_packages": matches[matches["severity"] == "critical"]["package"].tolist(),
        "high_severity_packages": matches[matches["severity"] == "high"]["package"].tolist(),
        "vulnerabilities": matches.to_dict("records"),
    }

    print(f"[Tool] Found {len(matches)} vulnerabilities in {repo_actual}")
    return json.dumps(result, indent=2, default=str)


@tool
def get_remediation_plan(repo_name: str = "", severity_threshold: str = "high") -> str:
    """Get actionable remediation plan for vulnerabilities.

    Args:
        repo_name: Specific repo to plan for (empty for all repos)
        severity_threshold: Minimum severity to include - 'critical', 'high', 'moderate', 'low'

    Returns:
        str: JSON with prioritized fix recommendations
    """
    print(f"[Tool] get_remediation_plan: repo={repo_name}, threshold={severity_threshold}")

    df = pd.DataFrame(VULNERABILITIES)

    if df.empty:
        return json.dumps({"error": "No vulnerability data available"})

    # Filter by repo if specified
    if repo_name:
        df = df[df["repo"].str.contains(repo_name, case=False, na=False)]

    if df.empty:
        return json.dumps({"error": f"No vulnerabilities found for repo '{repo_name}'"})

    # Filter by severity threshold
    severity_order = ["critical", "high", "moderate", "low", "info"]
    threshold_index = (
        severity_order.index(severity_threshold.lower()) if severity_threshold.lower() in severity_order else 1
    )
    df = df[df["severity"].isin(severity_order[: threshold_index + 1])]

    # Only fixable vulnerabilities
    fixable = df[df["fix_available"]]

    # Separate by major vs minor updates
    quick_fixes = fixable[~fixable["is_major_bump"]]
    breaking_changes = fixable[fixable["is_major_bump"]]

    # Unfixable
    unfixable = df[~df["fix_available"]]

    plan = {
        "scope": repo_name if repo_name else "All repositories",
        "severity_threshold": severity_threshold,
        "summary": {
            "total_to_fix": len(df),
            "quick_fixes": len(quick_fixes),
            "breaking_changes": len(breaking_changes),
            "unfixable": len(unfixable),
        },
        "quick_fixes": [
            {
                "package": row["package"],
                "repo": row["repo"],
                "severity": row["severity"],
                "current_range": row["vulnerable_range"],
                "fix_version": row["fix_version"],
                "command": f"npm update {row['package']}",
            }
            for _, row in quick_fixes.sort_values("severity").head(20).iterrows()
        ],
        "breaking_changes": [
            {
                "package": row["package"],
                "repo": row["repo"],
                "severity": row["severity"],
                "current_range": row["vulnerable_range"],
                "fix_version": row["fix_version"],
                "warning": "Requires major version update - test thoroughly",
                "command": f"npm install {row['package']}@{row['fix_version']}",
            }
            for _, row in breaking_changes.sort_values("severity").head(20).iterrows()
        ],
        "unfixable": [
            {
                "package": row["package"],
                "repo": row["repo"],
                "severity": row["severity"],
                "reason": "No fix available yet",
                "recommendation": "Monitor for updates or find alternative package",
            }
            for _, row in unfixable.sort_values("severity").head(10).iterrows()
        ],
    }

    print(
        f"[Tool] Generated plan: {plan['summary']['quick_fixes']} quick fixes, {plan['summary']['breaking_changes']} breaking changes"
    )
    return json.dumps(plan, indent=2)


@tool
def smart_search(search_term: str) -> str:
    """Search for vulnerabilities by BOTH repository name AND package name.

    Use this tool when the user asks about vulnerabilities "related to" or "for" something,
    as they might be referring to either a repo name or a package name.

    Args:
        search_term: Term to search for in both repo names and package names

    Returns:
        str: JSON with combined results from both repo and package searches
    """
    print(f"[Tool] smart_search: {search_term}")

    df = pd.DataFrame(VULNERABILITIES)

    if df.empty:
        return json.dumps({"error": "No vulnerability data available"})

    # Search in repo names (case-insensitive)
    repo_matches = df[df["repo"].str.contains(search_term, case=False, na=False)]

    # Search in package names (case-insensitive)
    package_matches = df[df["package"].str.contains(search_term, case=False, na=False)]

    # Get unique repos that matched
    matching_repos = repo_matches["repo"].unique().tolist()
    matching_packages = package_matches["package"].unique().tolist()

    # Build repo summaries
    repo_summaries = []
    for repo in matching_repos:
        repo_df = repo_matches[repo_matches["repo"] == repo]
        repo_summaries.append(
            {
                "repo": repo,
                "total_vulnerabilities": len(repo_df),
                "by_severity": repo_df["severity"].value_counts().to_dict(),
                "packages_affected": repo_df["package"].unique().tolist()[:10],
            }
        )

    # Build package summaries
    package_summaries = []
    for pkg in matching_packages[:20]:  # Limit to 20 packages
        pkg_df = package_matches[package_matches["package"] == pkg]
        package_summaries.append(
            {
                "package": pkg,
                "total_instances": len(pkg_df),
                "repos_affected": pkg_df["repo"].unique().tolist(),
                "severities": pkg_df["severity"].value_counts().to_dict(),
            }
        )

    result = {
        "search_term": search_term,
        "repos_found": len(matching_repos),
        "packages_found": len(matching_packages),
        "total_vulnerabilities_in_matching_repos": len(repo_matches),
        "total_vulnerabilities_for_matching_packages": len(package_matches),
        "matching_repos": repo_summaries,
        "matching_packages": package_summaries,
    }

    if not matching_repos and not matching_packages:
        result["message"] = f"No repos or packages found matching '{search_term}'"

    print(f"[Tool] Found {len(matching_repos)} repos and {len(matching_packages)} packages matching '{search_term}'")
    return json.dumps(result, indent=2, default=str)


@tool
def list_repos() -> str:
    """List all repositories being tracked.

    Returns:
        str: JSON list of repos with vulnerability counts
    """
    print("[Tool] list_repos")

    df = pd.DataFrame(VULNERABILITIES)

    if df.empty:
        return json.dumps({"repos": [], "total": 0, "message": "No vulnerability data available"})

    repos = []
    for repo in df["repo"].unique():
        repo_df = df[df["repo"] == repo]
        repos.append(
            {
                "name": repo,
                "vulnerability_count": len(repo_df),
                "critical": len(repo_df[repo_df["severity"] == "critical"]),
                "high": len(repo_df[repo_df["severity"] == "high"]),
                "moderate": len(repo_df[repo_df["severity"] == "moderate"]),
                "low": len(repo_df[repo_df["severity"] == "low"]),
                "fixable": int(repo_df["fix_available"].sum()),
            }
        )

    result = {"total_repos": len(repos), "repos": sorted(repos, key=lambda x: (x["critical"], x["high"]), reverse=True)}

    print(f"[Tool] Found {len(repos)} repositories")
    return json.dumps(result, indent=2)


def create_vulnerability_agent():
    """Create the vulnerability tracking agent using Claude Sonnet on Bedrock."""

    system_prompt = """You are a Security Vulnerability Assistant for development teams.

Your role is to help developers understand and remediate npm package vulnerabilities across multiple repositories.

AVAILABLE DATA:
- npm audit results from 100+ repositories
- Vulnerability details including severity, affected packages, and fix availability
- Direct vs transitive dependency information
- CVE/advisory references

TOOLS AVAILABLE:
- smart_search: **USE THIS FIRST** when user asks about vulnerabilities "related to", "for", or "about" something. Searches BOTH repo names AND package names.
- get_vulnerability_overview: Get high-level summary across all repos
- search_by_package: Find vulnerabilities for a specific npm package (use only if you know it's a package name)
- search_by_repo: Get vulnerabilities for a specific repository (use only if you know it's a repo name)
- get_remediation_plan: Get prioritized fix recommendations
- list_repos: See all tracked repositories

IMPORTANT - TOOL SELECTION:
- When the user asks "tell me about vulns for X" or "vulnerabilities related to X" - ALWAYS use smart_search first
- smart_search searches both repos and packages, so you won't miss results
- Only use search_by_package or search_by_repo if you are 100% certain what the user means

RESPONSE STYLE:
- Be clear and actionable - developers need to fix issues quickly
- Prioritize by severity: CRITICAL > HIGH > MODERATE > LOW
- Distinguish between direct dependencies (you control) and transitive (indirect)
- Call out breaking changes (major version bumps) vs safe updates
- Provide specific npm commands when giving remediation advice
- Use bullet points and clear structure

SEVERITY LEVELS:
- CRITICAL: Immediate action required, actively exploited vulnerabilities
- HIGH: High priority, fix within days
- MODERATE: Plan to fix in regular maintenance cycle
- LOW: Low priority, fix when convenient

KEY CONCEPTS:
- **Direct dependency**: Package listed in your package.json
- **Transitive dependency**: Dependency of your dependencies
- **Fix available**: Update exists that resolves the vulnerability
- **Major bump**: Breaking change version update (requires testing)

When discussing fixes:
1. Start with quick wins (non-breaking updates)
2. Then address breaking changes (need testing)
3. Finally handle unfixable issues (monitor or find alternatives)

Always be specific about which repo and which package you're discussing."""

    return Agent(
        model="us.anthropic.claude-sonnet-4-20250514-v1:0",
        tools=[
            smart_search,  # Primary search tool - searches both repos and packages
            get_vulnerability_overview,
            search_by_package,
            search_by_repo,
            get_remediation_plan,
            list_repos,
        ],
        system_prompt=system_prompt,
    )


# Create agent instance
vulnerability_agent = create_vulnerability_agent()


def run_vulnerability_agent(prompt: str) -> str:
    """Run the agent with a given prompt."""
    try:
        response = vulnerability_agent(prompt)
        return str(response)
    except Exception as e:
        return f"Error running agent: {str(e)}"


if __name__ == "__main__":
    print("Testing Vulnerability Agent...")
    print("-" * 50)

    test_prompt = "Give me an overview of vulnerabilities across all my repos"

    print(f"Prompt: {test_prompt}\n")
    response = run_vulnerability_agent(test_prompt)
    print(f"\nAgent Response:\n{response}")
